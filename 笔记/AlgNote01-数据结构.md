

### (一) 基础数据结构

数据结构本身并不解决问题，其主要作用是存储数据，并且提供增删改查的接口，数据结构是数据的容器，真正解决问题的，是在容器上面实现的算法。每种数据结构都有自己的强项与弱项，我们通过需要根据问题本身的增删改查到底需要什么范围之内的时间复杂度来决定使用何种数据结构来解决问题。目前算法竞赛主流语言是 C/CPP，因而本文所有代码均以 CPP 实现。



#### (1.1) 内建线性结构

- 静态定长数组 (Fixed-size Array)
- 动态变长数组 (Resizable Array)
- 排序与查找 (Sorting & Searching)
  - 排序使用 `sort`
  -   查找使用 `lower_bound` / `upper_bound` /  `binary_seach`
- 位图 (Bitmask, 通常使用线性结构模拟)
- 大整数 (Big Integer, 通常使用线性结构模拟) 
- 双端队列 (Deque, 只用双端队列其实即可模拟 Stack 与Queue)
  - 栈 (Stack，单调栈变体用于解决前项最值问题)
  - 普通队列 (Queue，单调队列变体用于解决滑动窗口最值问题)
  



这些经典的数据结构会在模拟题中频繁用到，例如使用栈解决括号匹配问题，中缀转后缀问题、后缀表达式计算等实际问题，以及树与图专题中，深度优先搜索与宽度优先搜索也会用到堆栈、队列作为辅助结构。



#### (1.2) 内建非线性结构

- 二叉堆优先队列 (Priority Queue)
- 平衡二分查找树 (Balanced Binary Search Tree)
  - 哈希表 (Hash Table)
    - 拉链法
    - 寻址法
  - 普通集合与多重集合 (Set & Multiset)
- 树存储结构 (Tree)
  - 双亲表示法 (使用`vector`记录自己的双亲节点)

  - 孩子表示法 (使用`vector<vi>`记录所有的孩子节点)

  - 兄弟表示法 (使用`vector<vii>`记录第一个孩子与第一个兄弟)

- 图存储结构 (Graph)
  - 连边表 (Edges List, 通常使用 `vector<iii>` 实现)
  - 邻接表 (Adjacency List, 通常使用 `vector<vii>` 实现)
  - 邻接矩阵 (Adjacency Matrix, 通常使用 `AM[N][N]` 实现)




平衡树通常不用自己实现，使用内置的哈希表容器或集合容器模拟即可，但当需要查找第k大元素的时候，如果`nth_element` 无法满足我们需求则要自行实现，AVL平衡树或红黑树等更加复杂的结构，掌握思想即可，一方面 IOI 或 ACM 比赛都很少会在复杂数据结构上面考察选择，另外一方面 ACM 类型的赛事允许携带纸质打印资料，其它类似的算法网络挑战赛等更是允许选手使用搜索引擎。

树结构或图结构，偶尔会遇到一些顶点 (Vertex) 信息无法使用数字表示的情况，对于这种较为复杂的图结构，可以先用 `map<string,int>` 映射做一趟预处理，或者直接使用带标签邻接表 (Labeled AL) 结构，也即 `unordered_map<string,vector<string>>` 结构实现存储。



#### (1.3) 数组模拟常用数据结构







### (二) 经典区间查询

- 前缀和与差分数组
- 树状数组
- 线段树
  - 覆盖式线段树
  - 榫卯式线段树 (更容易理解)



